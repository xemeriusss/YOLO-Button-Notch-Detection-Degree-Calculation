# -*- coding: utf-8 -*-
"""notches_detection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G9Pq0NwRbKZr8eTlZDViJmlhCu_xlW34
"""

!nvidia-smi

import os
HOME = os.getcwd()
print(HOME)

!pip install ultralytics==8.0.196

from IPython import display
display.clear_output()

import ultralytics
ultralytics.checks()

from ultralytics import YOLO

from IPython.display import display, Image

# VERSION 2 - 417 images
#!pip install roboflow

from roboflow import Roboflow
rf = Roboflow(api_key="___")
project = rf.workspace("berry-zykid").project("notch-detection-on-oven-buttons")
version = project.version(3)
dataset = version.download("yolov8")

!yolo task=detect mode=train model=yolov8m.pt data={dataset.location}/data.yaml epochs=40 imgsz=800 plots=True

!yolo task=detect mode=val model=/content/runs/detect/train/weights/best.pt data={dataset.location}/data.yaml

!yolo task=detect mode=predict model=/content/runs/detect/train/weights/best.pt conf=0.5 source={dataset.location}/test/images save=True

import glob
from IPython.display import Image, display

for image_path in glob.glob(f'/content/runs/detect/predict/*.jpg')[:20]:
      display(Image(filename=image_path, width=600))
      print("\n")

# import math
# import cv2

# def calculate_degree(image, annotations):
#     height, width, _ = image.shape
#     center_x, center_y = width // 2, height // 2

#     degrees = []
#     for annotation in annotations:
#         # Extract notch coordinates from annotation
#         notch_x, notch_y = annotation['x'], annotation['y']

#         # Calculate the angle relative to the center
#         angle = math.atan2(notch_y - center_y, notch_x - center_x)
#         degree = math.degrees(angle)

#         if degree < 0:
#             degree += 360

#         # Adjust the degree to account for the image's orientation
#         degree = (degree + 270) % 360

#         degrees.append(degree)

#     return degrees

print(dir(dataset))  # This will print all attributes and methods of the dataset object

######### GET BOUNDÄ°NG BOX COORDINATES

from pathlib import Path

# Load the model
model = YOLO('/content/runs/detect/train/weights/best.pt')

# Make predictions
predictions = model('/content/runs/detect/predict', save_txt=None)

# Create labels directory if it doesn't exist
labels_dir = Path("/content/runs/detect/labels")
labels_dir.mkdir(parents=True, exist_ok=True)

# Loop through each image in predictions
for prediction in predictions:
    image_path = Path(prediction.path)
    label_path = labels_dir / f"{image_path.stem}.txt"

    try:
        # Write the first bounding box to the label file
        if len(prediction.boxes) > 0:
            box = prediction.boxes.xywhn[0]
            cls = int(prediction.boxes.cls[0].item())
            x, y, w, h = box.tolist()
            with open(label_path, 'w') as file:
                file.write(f"{cls} {x} {y} {w} {h}\n")
    except Exception as e:
        print(f"Error processing {image_path}: {e}")

print("Label files created successfully.")

import cv2
import os
import math

def load_annotations(label_path):
    annotations = []
    with open(label_path, 'r') as file:
        for line in file:
            parts = line.strip().split()
            # Assuming label format: class x_center y_center width height
            # Convert from YOLO format to absolute coordinates (x, y)
            x, y = float(parts[1]), float(parts[2])
            annotations.append((x, y))
    return annotations

import math

def calculate_degree(image, annotations):
    height, width, _ = image.shape
    center_x, center_y = width // 2, height // 2

    degrees = []
    for (x, y) in annotations:
        # Convert relative to absolute coordinates
        notch_x, notch_y = x * width, y * height

        # Calculate the angle relative to the center
        angle = math.atan2(notch_y - center_y, notch_x - center_x)
        degree = math.degrees(angle)

        if degree < 0:
            degree += 360

        # Adjust degree for image orientation
        degree = (degree + 90) % 360
        formatted_value = f"{degree:.3f}"
        degrees.append(formatted_value)

    return degrees

# # Process each image in the dataset
# results = {}
# for image_info in dataset.images:
#     # Load the image using OpenCV
#     image = cv2.imread(image_info.filepath)

#     # Extract annotations for notches
#     notch_annotations = []
#     for obj in image_info.annotations:
#         x, y = obj['x'], obj['y']  # Replace with the correct keys if different
#         notch_annotations.append((x, y))

#     # Calculate the degrees of notches
#     degrees = calculate_degree(image, notch_annotations)

#     # Store results
#     results[image_info.filepath] = degrees

# # Example of outputting the results
# for filepath, degrees in results.items():
#     print(f'File: {filepath}, Degrees of Notches: {degrees}')

# TRAINED IMAGES VERSION
# Path to your dataset
dataset_path = '/content/Notch-Detection-on-Oven-Buttons-3'
train_images_path = os.path.join(dataset_path, 'train', 'images')
train_labels_path = os.path.join(dataset_path, 'train', 'labels')

# Process each image in the training set
for filename in os.listdir(train_images_path):
    if filename.endswith('.jpg'):  # Check for image files
        image_path = os.path.join(train_images_path, filename)
        label_path = os.path.join(train_labels_path, filename.replace('.jpg', '.txt'))

        image = cv2.imread(image_path)
        annotations = load_annotations(label_path)
        degrees = calculate_degree(image, annotations)

        print(f'File: {filename}, Degrees of Notches: {degrees}')



# # PREDICTED IMAGES VERSION
# # Path to your dataset
# dataset_path = '/content'
# train_images_path = os.path.join(dataset_path, 'runs/detect', 'predict')
# train_labels_path = os.path.join(dataset_path, 'runs/detect', 'labels')

# # Process each image in the training set
# for filename in os.listdir(train_images_path):
#     if filename.endswith('.jpg'):  # Check for image files
#         image_path = os.path.join(train_images_path, filename)
#         label_path = os.path.join(train_labels_path, filename.replace('.jpg', '.txt'))

#         image = cv2.imread(image_path)
#         annotations = load_annotations(label_path)
#         degrees = calculate_degree(image, annotations)

#         print(f'File: {filename}, Degrees of Notches: {degrees}')

import matplotlib.pyplot as plt

# Setup matplotlib figure
fig, axes = plt.subplots(5, 4, figsize=(20, 30))  # 2 rows, 5 columns
axes = axes.flatten()  # Flatten the axes array for easier iteration

# Process and display only the first 10 images
count = 0
for filename in os.listdir(train_images_path):
    if filename.endswith('.jpg') and count < 20:  # Check for image files and limit to 10
        image_path = os.path.join(train_images_path, filename)
        label_path = os.path.join(train_labels_path, filename.replace('.jpg', '.txt'))

        image = cv2.imread(image_path)
        annotations = load_annotations(label_path)
        degrees = calculate_degree(image, annotations)

        # Display image and degrees
        ax = axes[count]
        ax.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))  # Convert BGR to RGB for correct coloring
        ax.axis('off')  # Hide axes
        ax.set_title(f'Degrees: {degrees}')

        count += 1

plt.tight_layout()
plt.show()